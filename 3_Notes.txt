1) I/O redirection in bash script:
====================================
	So far in this course, the only type of input and output redirection that you've used, has been in the form of a pipe(|). You've already written scripts that redirect the standard output from one command and send it as standard input into another by separating those commands with a pipe(|). You've used that method to string together several commands in order to generate a random password, for example.
	
	Let's take a step back and talk about the different types of input and output. First of all, there are three types of I/O. They are standard input, standard output and standard error. By default, standard input comes from the keyboard. For example, the 'read' command accepts standard input and you use the 'read' command to collect information from a user typing something in at their keyboard. You also know, however, that standard input doesn't have to come from a keyboard. Again, you used pipes to take the output generated by one command and use that as the standard input for another command.
	
	Beyond standard input, there is standard output and standard error. By default, both standard output and standard error are displayed to the screen. Let's start out by redirecting the standard output of a command into a file and you can do that by using the greater than(>) sign. 
	
	By the way, you'll often see standard output abbreviated as STDOUT, standard input abbreviated as STDIN and standard error abbreviated as STDERR.
	
	We're going to be using a file several times throughout this script(luser-demo08.sh under shellclass_scripts_by_udemy/demos), so, I'm just going to assign that file name to a variable. I'm going to call that variable FILE	
		
		FILE="/tmp/data"
		head -n1 /etc/passwd > ${FILE}    -->   we'll send the standard output of 'head -n1 /etc/passwd' command into the FILE.
		
	Now remember, by default, standard output is displayed to the screen but since we are using the greater than symbol after the 'head -n1 /etc/passwd' command, it is redirecting that output away from the screen and send into the file we specified after the greater than sign.
	
		chmod 755 luser-demo08.sh   -->  provide executable permission to the script
		./luser-demo08.sh   --> run the script 
		
	As you can see, no output was generated by our script and that's pretty much to be expected because we told the output of the head command to go to a file.
		cat /tmp/data
		
	To be super clear, this output redirection is not part of any one command. It works with all the commands. While we're on the command line, let's try it out with.
		id -un > ambuj
		cat ambuj 
		
		echo "${UID}" > shukla   -->  if the file named 'shukla' is not present in the current directory then it would be created
		cat shukla
		
	By the way, file permissions are in play here too, so, if you try to redirect output into a file where you don't have write permissions, you're going to get an error.
		echo "${UID}" > /shukla  -->  output:  -bash: /shukla: Permission denied
		
	Let's look at the permissions on /.
		ls -ld / 
			output: 
				dr-xr-xr-x. 19 root root 4096 Jul 28 11:08 /
	
	They're set to 555 or read execute, read execute, read execute, with the owner of root and the group of root. Well, we're vagrant user and we're in the group of vagrant, so we have no write permissions. So, we can't create files there(/ directory). We can't do that either through output redirection or using any editor or by any other means. We just simply don't have permissions.
	
	Now, we know that the greater than sign(>) redirects standard output. Well, to redirect standard input from, use the less than sign(<). Again, standard input is often abbreviated STDIN. Let's take an example with the 'read' command. Create a file named 'myname' on the current directory with the contents of your full name.
		read "Enter your full name: " NAME < myname  -->  output:  -bash: read: `Enter your full name: ': not a valid identifier
		read NAME < myname   --> this will work
		
	You've used the 'read' command to accept standard input from a user. By using input redirection, you are now accepting standard input from a file. The read command reads one line of standard input. When someone is typing at the keyboard and they hit Enter, that represents one line of standard input. Of course, when dealing with files, a new line character will cause read to stop. So, the variable NAME should contain the first line of the file.
	
	Redirecting standard input from a file works with any command that accepts standard input. Take the 'passwd' command as an example. Let's put some text into a file and we can do that with the echo command.
		echo "secret" > password    -->  A file named 'password' would be created with contents 'secret'
		cat password
		
	Now, let's use this file(password file) as standard input to the passwd command.
		sudo passwd --stdin einstein < password   --> we are changing the password for the einstein user 
		
	The first method you used was with a pipe(echo "secret" | sudo passwd --stdin einstein) but now, you can also use this input redirection with the less than sign. And remember, the difference between these methods is that in a pipe, the standard input comes from the output of a command whereas with this less than symbol, the standard input comes from a file. So, that's the difference.
	
	It's important to know that using a single greater than sign(>) to perform a output redirection creates a new file if that file doesn't exist or it overwrites/overrides the contents of that file if it does exist. So right now, the password file contains the word 'secret'. If we perform an output redirection to that file, it will get overridden.	
		cat password
			output:
				secret
		
		echo "new" > password
		cat password
			output:
				new 
				
	So, what if you don't want to override/overwrite a file but you want to add or append to it. In that case, you use double greater than symbol(>>). So, let's look at the contents of our password file here, in our current directory. It contains just one line and that line says 'new'. Now let's add another line to the file using >>.
		cat password
			output:
				new 
				
		echo "another-line" >> password
		cat password
			output:
				new
				another-line
				
		date | sha256sum | head -c10 >> password    -->   So here, we used pipes and output redirection.
		cat password
		
2) File Descriptor:
=====================
	Before we cover redirecting standard error, we need to talk about file descriptors. A file descriptor is simply a number that represents an open file. For us humans, it's easier for us to reference files by name but it's easier for computers to reference them(i.e., files) by number. By default, every new process starts with three open file descriptors. They are file descriptor zero which is standard input, file descriptor one which is standard output and file descriptor two which is standard error. You may be thinking, hold on, by default, standard input comes from my keyboard but my keyboard isn't a file and by default, standard output and standard error are displayed to my screen but my screen isn't a file either. On one level, that's true but Linux represents practically everything as a file. Perhaps a more accurate description of a file descriptor is that it's a way that a program interacts with files or to other resources that work like files. These other resources include devices such as keyboards, terminals and so on. This abstraction of treating almost everything like a file allows you to do some really powerful things like take the standard output of one command, that would normally be displayed to your screen, and use it as input to another command. Of course, I'm talking about pipes in this case. So file descriptors are like pointers to sources of data or places where data can be written, things like keyboards, files, screens, and so on.

	Okay, back to I/O. So far in this lesson, we've been using the implicit way of redirecting input and output. For example, when we redirect standard input into a command, file descriptor zero is assumed.
	
	Let's look at the contents of a file(i.e., /etc/centos-release) on our system.
		cat /etc/centos-release
			output:
				CentOS Linux release 7.3.1611 (Core)
			
	Now let's use that file as standard input, let's say, to the read command. So, we're going to read, into the variable VAR, the contents of /etc/centos-release.
		read VAR < /etc/centos-release
	
	Now, if we echo ${VAR}, we'll see the contents of that file.
		echo ${VAR} 
			output:
				CentOS Linux release 7.3.1611 (Core)
	
	So, sure enough, that input redirection worked and that's the implicit way to do it. If you want to be explicit, specify the file descriptor number right before the redirection operator.
		read VAR 0< /etc/centos-release
		echo ${VAR} 
			output:
				CentOS Linux release 7.3.1611 (Core)
				
	The reason it's the same output is because if you don't supply a file descriptor then zero is assumed for standard input. So, the previous redirection is the same thing as this.
	
	Below is the implicit way of output redirection. If no file descriptor is given then file descriptor one is assumed when using the greater than symbol.
		echo "${UID}" > uid   
		cat uid 
			output:
				<uid_of_the logged-in user>
		
	Let's be explicit with standard output redirection. The previous command is the exact same thing as this if we specify 1 as a file descriptor right before the greater than sign.
		echo "${UID}" 1> uid   
		cat uid 
			output:
				<uid_of_the logged-in user>
				
3) Standard Error:
=======================
	By convention, normal program output is sent to standard output while error messages are sent to standard error. When you're working at the command prompt, you may not even notice the difference because again, by default, they are both displayed to the screen.
	
	Let's make a program generated error. we can supply multiple files to the 'head' command(to get more detail, run 'man head'). And here's what that looks like.
		head -n1 /etc/passwd /etc/hosts
			output:
				==> /etc/passwd <==
				bin:x:1:1:bin:/bin:/sbin/nologin

				==> /etc/hosts <==
				127.0.0.1       localhost

	Now let's use a file that doesn't exist.
		head -n1 /etc/passwd /etc/hosts /fakefile
			output:
				==> /etc/passwd <==
				bin:x:1:1:bin:/bin:/sbin/nologin

				==> /etc/hosts <==
				127.0.0.1       localhost
				head: cannot open '/fakefile' for reading: No such file or directory
				
	Even though you can't tell by looking at the output, there is both standard output and standard error generated here. Let's redirect standard output to a file. Since standard error was not redirected, it was sent to the screen. And of course, that error message is that file cannot be found and the normal standard output is saved into this head.out file.
		head -n1 /etc/passwd /etc/hosts /fakefile > head.out 
			output:
				head: cannot open '/fakefile' for reading: No such file or directory
		
		cat head.out
			output:
				==> /etc/passwd <==
				bin:x:1:1:bin:/bin:/sbin/nologin

				==> /etc/hosts <==
				127.0.0.1       localhost
				
	Let's redirect standard error. And the way to do that is to specify its file descriptor of two.
		head -n1 /etc/passwd /etc/hosts /fakefile 2> head.err
			output:
				==> /etc/passwd <==
				bin:x:1:1:bin:/bin:/sbin/nologin

				==> /etc/hosts <==
				127.0.0.1       localhost
				
		cat head.err
			output:
				head: cannot open '/fakefile' for reading: No such file or directory
				
		rm head.out head.err   --> remove/delete the specified files 
		
	We can even get real fancy here and redirect standard output to one file while redirecting standard error to another.
		head -n1 /etc/passwd /etc/hosts /fakefile > head.out 2> head.err   --> now, no output will be displayed on the screen 
		cat head.out   --> Standard output is in this file 
		cat head.err   --> Standard error is in this file
		
	By the way, appending output/error is probably what you would expect.
		head -n1 /etc/passwd /etc/hosts /fakefile > head.out 2>> head.err
		cat head.err
			output:
				head: cannot open '/fakefile' for reading: No such file or directory
				head: cannot open '/fakefile' for reading: No such file or directory
				
	What if you wanna send standard output and standard error to the same place/file? 
		There are a couple of different ways to accomplish this. I'm going to show you the older syntax first and then the new syntax right after that. You're going to see the standard output and the standard error both in that one file.
			head -n1 /etc/passwd /etc/hosts /fakefile > head.both 2>&1   -->  old syntax  
			cat head.both   -->  you're going to see the standard output and the standard error both in that one file.
			
	A number that comes directly before a redirect operator is a file descriptor. The only new piece in the above command is the ampersand symbol. Normally, with redirection, a file name follows the redirection operator. However, if you want to use a file descriptor instead of a file name then use the ampersand symbol. &1 means we are referring to the file used for capturing standard output(&1 represents standard output file). If you omit the ampersand from the above command then 1 would be treated as a file named 1. I'd like to point out here that spacing is important as well. Do not use the space after the redirection operator and the ampersand. 

		rm head.both
		head -n1 /etc/passwd /etc/hosts /fakefile &> head.both   -->  new syntax  
		cat head.both   -->  you're going to see the standard output and the standard error both in that one file.
		
	Again, using double greater than sign(>>) appends to the file.
		head -n1 /etc/passwd /etc/hosts /fakefile &>> head.both
		cat head.both
		
		rm head.both
		
	If you think back to when you first started using pipes, you learned that a pipe takes the standard output of one command and uses it as standard input for another command. This means that standard error doesn't flow through the pipe. Let's demonstrate this. First, let's take a look at the cat man page.
		man cat 
		
		head -n1 /etc/passwd /etc/hosts /fakefile  --> this command gives 6 lines of output
		
	You can see, first, standard error is displayed to the screen because it was not passed through the pipe, the standard output of the head command was passed through the pipe as the input to the cat command. The cat command numbered each file it received as standard input.	
		head -n1 /etc/passwd /etc/hosts /fakefile | cat -n   --> '-n' option is for 'number all output lines'
			output:
				head: cannot open '/fakefile' for reading: No such file or directory
					1  ==> /etc/passwd <==
					2  bin:x:1:1:bin:/bin:/sbin/nologin
					3
					4  ==> /etc/hosts <==
					5  127.0.0.1       localhost
					
	Now, this could be exactly the way you want things to work when you're working with pipes or it might not be. If you want to force all the output of a command through the pipe then you need to append the standard error to the standard input. So, one way we can do this is to specify a file descriptor of two, which is for standard error and then redirect that into ampersand one, which represents the file descriptor one, which in turn represents standard output. So now, that standard error is going to standard output and all the standard output goes through the pipe then cat should count all of our lines.
		head -n1 /etc/passwd /etc/hosts /fakefile 2>&1 | cat -n
			output:
				1  ==> /etc/passwd <==
				2  bin:x:1:1:bin:/bin:/sbin/nologin
				3
				4  ==> /etc/hosts <==
				5  127.0.0.1       localhost
				6  head: cannot open '/fakefile' for reading: No such file or directory
				
	Now, there's a shorthand for this. It's pipe ampersand(|&). It combines the standard error and standard output into one and then passes that through the pipe, so we get the same result. 
		head -n1 /etc/passwd /etc/hosts /fakefile |& cat -n
			output:
				1  ==> /etc/passwd <==
				2  bin:x:1:1:bin:/bin:/sbin/nologin
				3
				4  ==> /etc/hosts <==
				5  127.0.0.1       localhost
				6  head: cannot open '/fakefile' for reading: No such file or directory

	So, we've appended standard error to standard output. Let's do the opposite, which is to append standard output to standard error.
		echo 'error' | cat -n 
			output:
				1  error
				
		echo 'error' >&2  -->  Putting something in the STDERR
		echo 'error' >&2 | cat -n
			output:
				error  -->  Since there is nothing in the STDOUT command, nothing will be passed to 'cat' command. 
				
	Now, remember that the ampersand that follows the redirection operator is used when you want to use a file descriptor instead of a file name. And, to be super clear, this is exactly the same as this(below) one greater than ampersand two.
		echo 'error' 1>&2 
		
	Now, why would you ever want to do this?
		Mainly, so that, you can make your scripts conform to the standard convention of sending error messages to standard error. If you find yourself writing an 'exit' command in a script and echoing some information just before that, that's a really good sign that you need to send the output of those echo commands to standard error.
		
4) Null device:
==================
	The null device is a special file that throws away whatever is sent to it. So, if you don't want to see output on your screen and you don't wanna save that output to a file either then redirect that output to the null device, which is located at /dev/null.
		head -n1 /etc/passwd /etc/hosts /fakefile
			output:
				==> /etc/passwd <==
				bin:x:1:1:bin:/bin:/sbin/nologin

				==> /etc/hosts <==
				127.0.0.1       localhost
				head: cannot open '/fakefile' for reading: No such file or directory
				
	Now, let's discard the standard output. So, we'll just send the standard output to /dev/null. So, all we're left with is standard error.
		head -n1 /etc/passwd /etc/hosts /fakefile > /dev/null 
			output:
				head: cannot open '/fakefile' for reading: No such file or directory
				
	Now, we can do the same thing here with standard error i.e., just throw away the standard error. So, we're left with standard output only.
		head -n1 /etc/passwd /etc/hosts /fakefile 2> /dev/null
			output:
				==> /etc/passwd <==
				bin:x:1:1:bin:/bin:/sbin/nologin

				==> /etc/hosts <==
				127.0.0.1       localhost
				
	Now, let's throw away all the output generated by the command. And we know how to do that because we can use this ampersand greater than sign(&>) to combine standard output and standard error and put that combination in standard output i.e., STDOUT and we'll redirect that to /dev/null, so no output is generated.
		head -n1 /etc/passwd /etc/hosts /fakefile &> /dev/null
		echo $?
			output:
				1
		
	You might wonder when you would want to do such a thing. Well, here is the use case. If you are executing a command in your script and you don't want the user, who is running the script, to see the output of that command then send it to /dev/null. And remember, if you need to know that a command succeeded or not, simply check its exit status. You don't need the output to determine if it succeeded or failed.
		head -n1 /etc/passwd /etc/hosts &> /dev/null
		echo $?
			output:
				0
				
5) Case Statement:
====================
	First off, it's a shell builtin
		type -a case
			output:
				case is a shell keyword
	
	It says 'case' is a shell keyword which is a type of shell builtin. Of course, since it's a shell builtin, you know that we can get some information on how to use it with the 'help' built-in.
		help case 
		
	In the 'help' output for the case statement, it says that you can use a pipe(|) to separate multiple patterns for a case.
	For example, on older Linux distributions, you would run '/etc/init.d/sshd status' and you would be provided with the status of the SSHD service. Likewise, you would stop the service by executing '/etc/init.d/sshd stop' and so on and so forth, just kind of like we have laid_out/written_it_in here(luser-demo09.sh under shellclass_scripts_by_udemy/demos). All the system's services were handled by a simple shell script that used a case statement.
		
6) Patterns in bash script:
===============================
	So, let's quickly reference the bash man page and get some more information on patterns as they are used with a 'case' statement.
		man bash 
		
	I'm gonna search for the 'case' word here  --> It says to see Pathname Expansion
	So, let's search for 'pathname exp'. Really, what we're looking for in this section is about 'pattern matching'. So, let me just page down here until we get it.
	
	If you want to get a list of files that end with 'txt', you would run 'ls -al *txt'.
	
7) Line continuation character in Linux terminal:
===================================================
	'\' is a line continuation character in Linux terminal. You can write a big command in multiple lines and those lines will be appended by the Linux OS
		ls -al\
		> *txt   -->  give a space before '*txt' then only it will be valid command i.e., 'ls -al *txt'
		
8) Function in bash script:
=============================
	One way to create a function is to use the 'function' built-in command.
		help function
		
	Create a bash script named luser-demo10.sh and add the below contents to it.
		#!/bin/bash 
		log() {
			echo 'You called the log function!'
		}
		
		log  --> to call the function, just use the function name i.e., log here 
		
	Now, remember that scripts get read and executed from the top down. That means you have to define a function before you can use it. That's why we defined the 'log' function at the top of your script here(above). When a function is defined, it is read/loaded into memory and it's then available for use. The code in the function is just remembered initially and it's only executed when it gets called. Notice that, when we called the function, we didn't use the parentheses. You may have seen this type of syntax and style in other programming languages where you actually use the parentheses but it doesn't work in shell scripts. Simply place the name of a function on a line and it will execute that function.
	
	Alternate way to create function
		#!/bin/bash 
		function log {
			echo 'You called the log function!'
		}
		
		log
			output:    -->  execute the script by running this './luser-demo10.sh'
				You called the log function!
		
	Functions act like a script within your script and they can accept arguments which can be then accessed as positional parameters inside the function. For example, the first argument passed to a function is ${1}, the second is ${2}, and so on. The only difference between a function and a script here is that ${0} is still the name of the shell script itself and not the name of the function. Now, let's make our 'log' function display to the screen whatever is passed to it. When we execute our script(below one), the function is called first time with "Hello!" which gets printed to the screen. The second time the function is called with "This is fun!" and that also gets displayed to the screen.
		#!/bin/bash 
		function log {
			local MESSAGE="${@}"
			echo "${MESSAGE}"
		}
		
		log 'hello!'
		log 'This is fun!'
			output:     -->  execute the script by running this './luser-demo10.sh'
				hello!
				This is fun!
				
	Now, let's update our function to only display the message, that was passed to it, on the screen if a global variable named VERBOSE is set to true. So we'll check to see if VERBOSE is true, and if it is then we'll echo that message to the screen.
		#!/bin/bash 
		function log {
			local MESSAGE="${@}"
			if [[ "${VERBOSE}" = 'true' ]]
			then
			  echo "${MESSAGE}"
			fi 
		}
		
		log 'hello!'
		VERBOSE='true'
		log 'This is fun!'
			output:     -->  execute the script by running this './luser-demo10.sh'
				This is fun!
				
		OR 
				
		#!/bin/bash 
		function log {
			local VERBOSE="${1}"
			shift 
			local MESSAGE="${@}"
			if [[ "${VERBOSE}" = 'true' ]]
			then
			  echo "${MESSAGE}"
			fi 
		}
		
		log 'false' 'hello!'
		log 'true' 'This is fun!'
			output:     -->  execute the script by running this './luser-demo10.sh'
				This is fun!
	In practice, the VERBOSITY is going to remain the same for our entire script. Because of that, I could argue that passing it into the function every single time is causing us to repeat ourselves without any real practical gain. In this example, I think using a global variable is fine.		
		#!/bin/bash 
		function log {
			local VERBOSE="${1}"
			shift 
			local MESSAGE="${@}"
			if [[ "${VERBOSE}" = 'true' ]]
			then
			  echo "${MESSAGE}"
			fi 
		}
		
		VERBOSITY='true'
		log "${VERBOSITY}" 'hello!'
		log "${VERBOSITY}" 'This is fun!'
			output:     -->  execute the script by running this './luser-demo10.sh'
				hello!
				This is fun!
				
	If we were doing something like differentiating informational(info) messages from warning messages from critical messages then passing in that log-level would make sense because it can change throughout our script.
	
	The main concern of using global variables within functions is that a function might actually change the value of that global variable, so we'll do like below.
		#!/bin/bash 
		log() {
			local MESSAGE="${@}"
			if [[ "${VERBOSE}" = 'true' ]]
			then
			  echo "${MESSAGE}"
			fi 
		}
		
		readonly VERBOSE='true'
		log 'hello!'
		log 'This is fun!'
			output:     -->  execute the script by running this './luser-demo10.sh'
				hello!
				This is fun!
				
	Now that, the VERBOSE variable is readonly, it cannot be changed for the duration of the script. That means, it cannot be changed inside or outside of a function. That eliminates the concern about a function changing the value of a global variable.
	
	You're probably already familiar with the /tmp directory. However, here, I'm using /var/tmp because the files in /var/tmp will survive a reboot, while those in /tmp are not guaranteed to survive a reboot. Typically, the files in /tmp are cleared on boot and are also cleared more often on a running system. I think, the default for CentOS 7 is that files in /tmp are deleted every 10 days, while the files in /var/tmp are deleted every 30 days. As you know, the basename command removes the path to the file and just leaves us with a file name. We don't care about its original path because we're just gonna put a copy of it in /var/tmp, anyway. Also, here we're using command substitution with the date command and you've used the date command with a couple of different formats before but now I'm introducing the capital F format. Now, capital F you can think of as standing for full date and it displays the year, month, day using numbers. I love using this format because it makes sorting by date very easy. Once we call this function a couple of times, you'll see exactly what I mean. Also, I attempted to account for multiple backups of the same file on the same day by appending the nanoseconds when the date command was called. That's represented by the percent sign followed by capital N. So now, in this function(backup_file function), let's call our other function(log function) here. So after we use the 'log' function to record what we're going to do here or communicate our intentions here, then we're going to use the 'cp' command to actually perform a copy. Now, the '-p' option to the copy command is short form for preserve and it preserves the file's mode, ownership, and timestamps. If you don't use the '-p' option then the copy of the original file will have the current timestamp. I personally like to preserve the original timestamp on the copy, just in case I need to put that copy back in place. Because it's a backup, the contents of that file haven't changed, so in my opinion, it makes sense to keep its timestamps the way they were instead of updating the timestamp to today. Each function, like each command, returns an exit status. By default, the function returns the exit status of the last command it executes. In the case, where the file that was passed to the function actually exists, we'll just let cp return whatever exit status is appropriate and use that as the exit status for our function. If for some reason the cp command fails, it will return a non-zero exit status and thus our 'backup_file' function will return that same non-zero exit status. Here, if the file doesn't exist, that means we obviously can't make a copy of it, a backup copy of it, so our function more or less fails and that's why we are going to return a non-zero exit status. That's means we are exiting from the function. 
	
		backup_file() {
			# This function creates a backup of a file.  Returns non-zero status on error.

			local FILE="${1}"

			# Make sure the file exists.
			if [[ -f "${FILE}" ]]
			then
			  local BACKUP_FILE="/var/tmp/$(basename ${FILE}).$(date +%F-%N)"
			  log "Backing up ${FILE} to ${BACKUP_FILE}."

			  # The exit status of the function will be the exit status of the cp command.
			  cp -p ${FILE} ${BACKUP_FILE}
			else
			  # The file does not exist, so return a non-zero exit status.
			  return 1
			fi
	    }
		backup_file '/etc/passwd'  -->  let's backup the /etc/passwd file 
		
		if [[ "${?}" -eq '0' ]]
		then
		  log 'File backup succeeded!'
		else
		  log 'File backup failed!'
		  exit 1
		fi
		
			output:
				hello!
				This is fun!
				Backing up /etc/passwd to /var/tmp/passwd.2024-09-04-082801552
				File backup succeeded!
				
	So let's see if these messages made it to the log file.
		sudo tail /var/log/messages
		
	Now let's a look at the file(backup file) we copied here into /var/tmp.
		ls -l /var/tmp
	
	By the way, inside a function, it's super important to use 'return' and not 'exit'. If the 'exit' command gets executed, it exits the entire script, no matter if that exit command is inside a function or not. So 'exit', remember, the 'exit' is for the entire script, return is just for the function.
	
		type -a backup_file
		
9) local shell built-in:
=============================
	I've introduced a new shell built-in called 'local'. What 'local' does is it makes a variable local in scope to the function. That means the value of that variable is only accessible inside that function. By the way, the 'local' command can only be used inside a function, that's the only place it makes sense. Until now, we've been using global variables and that means that the variable can be accessed from anywhere in the script including in any function.
	
	By the way, if you define a global variable in a function by omitting the local keyword in front of it, that global variable is not available outside that function until the function is called and executed. It's not a best practice to do that anyway. 
	
	By default, all variables are global in scope and you can use the 'local' keyword to define local variables, that are only available within the function that they are defined in.
	
10) readonly shell built-in:
===============================
	The readonly shell built-in makes a variable unchangeable or unmodifiable. This is the shell's version of a constant variable. There are two ways to use the readonly shell built-in. 
	One is to use the word readonly followed by the variable and then include the variable assignment there right after it.
		readonly VERBOSE='true'
	
	The other way is to perform the variable assignment first and then use readonly followed by just the variable name. There's no need to include the assignment because it's already performed before.
		VERBOSE='true'
		readonly VERBOSE
		
11) logger in Linux:
=========================
		type -a logger  --> 	'logger' is a executable
	so, we can run man against that to get some information about that particular command.
		man logger
	
	Mainly, you just supply 'logger' a message and that message is recorded in the system's log. By default, on a CentOS or RHEL system, those messages will go to the /var/log/messages file.
		logger 'Hello from the command line!'
	
	All right, now, we want to look at the /var/log/messages file and that file happens to have permissions such that we need 'root' to read that file.
		sudo tail /var/log/messages
		
		logger -t my-script 'Tagging on!'    -->  '-t' option is for providing the tag
		sudo tail /var/log/messages
		
12) How can a Linux/Unix Bash script get its own PID?
========================================================
	The variable $$ contains the PID($$ expands to the pid or process ID of the current running script). You can also use $BASHPID variable.  
	
13) Parsing Command Line Options with getopts:
==================================================
	We'll learn how to process command line options using the shell built-in 'getopts'. If you want your shell scripts to behave like other Linux executables, you're going to want to allow users to specify options that change the behavior of your scripts. For example, you might want to give the user a verbose option where the user sees a lot of output from your script or maybe you want to give them a quiet option where your script does its work silently and then only reports if it has an error.
	
	Probably one of the first commands you learned how to use on a Linux system was 'ls'. Right after learning that ls(lists files), you probably learned about the '-l' option which makes ls, list files, in a long listing format, giving you more information.
	
	You could use an if statement or a case statement to check for individual options like -l or -a in your script. However, you'll want to allow the user to combine those short options together, so that '-l -a' performs exactly like '-la' or '-al'. Doing that with a simple case statement is actually kind of hard and getopts handles this and other little gotchas when working with options and that's one of the reasons why we're going to learn it here today.
	
	getopts is a shell built-in/.
		type -a getopts
		
	There is a very similar command called 'getopt', that's singular, that you might see in some older scripts. 'getopt' is an executable on the file system
		type -a getopt
			output:
				getopt is /usr/bin/getopt
	
	'getopt' is very similar to 'getopts' but it has its limitations and its own set of unique quirks. If you're interested in learning more about it or you end up having to dive into the details of it at some point because you run across a script that has 'getopt' in it then just read the Man Page on getopt and you'll be well on your way.
		man getopt
		
	Now, let's get some help on the 'getopts' built-in function here.
		help getopts | less 
		
	Syntax:  getopts optstring name [arg]
		So, the optstring is something that you are going to provide. These are the options that your script is going to recognize and accept. It's just a series of letters that are going to be your options. If you want to make an option have a mandatory value, then follow that letter option with a colon.. Next, you're going to provide a name. It's a variable that's going to get populated with an option provided by user. That way you can do something based on that option because you have no idea what a user is going to do and how many options they may try to supply. So, you'll need to use 'getopts' in a while loop. 'getopts' returns zero as long as it finds an option to process, otherwise, it returns one which will cause the while loop to exit. Finally, 'getopts' parses positional parameters by default but you can make it parse something else entirely by providing it with an argument at the end.
		
	Create a bash script named luser-demo11.sh and add the below contents to it.
		#!/bin/bash
		LENGTH=48
		
		while getopts vl:s OPTION
		do
		  case ${OPTION} in
			v)
			  VERBOSE='true'
			  echo 'Verbose mode on.'
			  ;;
			l)
			  LENGTH="${OPTARG}"
			  ;;
			s)
			  USE_SPECIAL_CHARACTER='true'
			  ;;
			?)
			  echo 'Inavlid option.' >&2
			  exit 1
			  ;;
		  esac
		done
		
	Save the script.
		chmod 755 luser-demo11.sh
		./luser-demo11.sh -s
		./luser-demo11.sh -v
			output:
				Verbose mode on.
				
		./luser-demo11.sh -l   -->  '-l' option mandates an argument to be passed. So you will end up with an error 
		./luser-demo11.sh -l 16
		
		./luser-demo11.sh -x   -->  not a valid option which the script accepts. So you will end up with an error
		
	'getopts' does not change positional parameters. What this means is that the options are stored in ${@}, ${1}, ${2}, and so on.
		#!/bin/bash
		LENGTH=48
		
		while getopts vl:s OPTION
		do
		  case ${OPTION} in
			v)
			  VERBOSE='true'
			  echo 'Verbose mode on.'
			  ;;
			l)
			  LENGTH="${OPTARG}"
			  ;;
			s)
			  USE_SPECIAL_CHARACTER='true'
			  ;;
			?)
			  echo 'Inavlid option.' >&2
			  exit 1
			  ;;
		  esac
		done
		
		echo "Number of args: ${#}"
		echo "All args: ${@}"
		echo "First arg: ${1}"
		echo "Second arg: ${2}"
		echo "Third arg: ${3}"
		
	Run the above script like './luser-demo11.sh -sl 8 extra-stuff'. Remember extra-stuff is not an option to our shell script because we didn't put hypen(-) in front of it. 
		output:
			Number of args: 3
			All args: -sl 8 extra-stuff
			First arg: -sl
			Second arg: 8
			Third arg: extra-stuff

	Don't think like, once the arguments are processed, they should be removed as a positional parameter. Now, getopts doesn't do this for us but it gives us a way to do it. 'getopts' sets a variable named OPTIND. That variable stores the position of the next command line argument following the options.
		#!/bin/bash
		LENGTH=48
		
		while getopts vl:s OPTION
		do
		  case ${OPTION} in
			v)
			  VERBOSE='true'
			  echo 'Verbose mode on.'
			  ;;
			l)
			  LENGTH="${OPTARG}"
			  ;;
			s)
			  USE_SPECIAL_CHARACTER='true'
			  ;;
			?)
			  echo 'Inavlid option.' >&2
			  exit 1
			  ;;
		  esac
		done
		
		echo "Number of args: ${#}"
		echo "All args: ${@}"
		echo "First arg: ${1}"
		echo "Second arg: ${2}"
		echo "Third arg: ${3}"
		
		echo "OPTIND: ${OPTIND}"
		
	Run the above script like './luser-demo11.sh -sl 8 extra-stuff'. Remember extra-stuff is not an option to our shell script because we didn't put hypen(-) in front of it. 
		output:
			Number of args: 3
			All args: -sl 8 extra-stuff
			First arg: -sl
			Second arg: 8
			Third arg: extra-stuff	
			OPTIND: 3  --> OPTIND is set to three because the third place is the index or position where the arguments start after the options
			
	If we want to remove the options that have been processed by 'getopts', that means we need to shift them down/right by two because OPTIND is set to 3, so that we will left with the things/arguments that have been supplied after the options. So stated mathematically, that's OPTIND minus one.
		#!/bin/bash
		LENGTH=48
		
		while getopts vl:s OPTION
		do
		  case ${OPTION} in
			v)
			  VERBOSE='true'
			  echo 'Verbose mode on.'
			  ;;
			l)
			  LENGTH="${OPTARG}"
			  ;;
			s)
			  USE_SPECIAL_CHARACTER='true'
			  ;;
			?)
			  echo 'Inavlid option.' >&2
			  exit 1
			  ;;
		  esac
		done
		
		echo "Number of args: ${#}"
		echo "All args: ${@}"
		echo "First arg: ${1}"
		echo "Second arg: ${2}"
		echo "Third arg: ${3}"
		
		echo "OPTIND: ${OPTIND}"
		
		# Remove the options while leaving the remaining arguments
		shift "$(( OPTIND - 1 ))"
		
		echo 'After the shift:'
		echo "All args: ${@}"
		echo "First arg: ${1}"
		echo "Second arg: ${2}"
		echo "Third arg: ${3}"
		
	Run the above script like './luser-demo11.sh -s extra-stuff'. Remember extra-stuff is not an option to our shell script because we didn't put hypen(-) in front of it. 
		output:
			Number of args: 2
			All args: -s extra-stuff
			First arg: -s
			Second arg: extra-stuff
			Third arg: 	
			OPTIND: 2
			After the shift:
			All args: extra-stuff
			First arg: extra-stuff
			Second arg: 
			Third arg:
			
	Let's say, in this particular script(i.e., luser-demo11.sh), we want to treat anything(any argument) other than the options on the command line as an error. The easiest way to do that is to test the ${#} value.
		#!/bin/bash
		usage() {
		  echo "Usage: ${0} [-vs] [-l LENGTH]" >&2
		  echo 'Generate a random password.' >&2
		  echo '  -l LENGTH  Specify the password length.' >&2
		  echo '  -s         Append a special character to the password.' >&2
		  echo '  -v         Increase verbosity.' >&2
		  exit 1
		}
		
		LENGTH=48
		
		while getopts vl:s OPTION
		do
		  case ${OPTION} in
			v)
			  VERBOSE='true'
			  echo 'Verbose mode on.'
			  ;;
			l)
			  LENGTH="${OPTARG}"
			  ;;
			s)
			  USE_SPECIAL_CHARACTER='true'
			  ;;
			?)
			  echo 'Inavlid option.' >&2
			  exit 1
			  ;;
		  esac
		done
		
		# Remove the options while leaving the remaining arguments
		shift "$(( OPTIND - 1 ))"
		
		if [[ "${#}" -gt 0 ]] 
		then 
		  usage
		fi
	
	Run the above script like './luser-demo11.sh extra-stuff' or './luser-demo11.sh -s extra-stuff'. It will give the usage message to the user and exit the script with a non-zero exit status.
	Run the above script like './luser-demo11.sh -s'  -->  no output and the script exists with zero exit status 
	
	And remember, when you use shift, the number of arguments changes and that also updates the ${#} variable.
					
		

